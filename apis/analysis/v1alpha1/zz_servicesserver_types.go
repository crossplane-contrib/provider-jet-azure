/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IPv4FirewallRuleObservation struct {
}

type IPv4FirewallRuleParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	RangeEnd *string `json:"rangeEnd" tf:"range_end,omitempty"`

	// +kubebuilder:validation:Required
	RangeStart *string `json:"rangeStart" tf:"range_start,omitempty"`
}

type ServicesServerObservation struct {
	ServerFullName *string `json:"serverFullName,omitempty" tf:"server_full_name,omitempty"`
}

type ServicesServerParameters struct {

	// +kubebuilder:validation:Optional
	AdminUsers []*string `json:"adminUsers,omitempty" tf:"admin_users,omitempty"`

	// +kubebuilder:validation:Optional
	BackupBlobContainerURISecretRef v1.SecretKeySelector `json:"backupBlobContainerUriSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	EnablePowerBiService *bool `json:"enablePowerBiService,omitempty" tf:"enable_power_bi_service,omitempty"`

	// +kubebuilder:validation:Optional
	IPv4FirewallRule []IPv4FirewallRuleParameters `json:"ipv4FirewallRule,omitempty" tf:"ipv4_firewall_rule,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	QuerypoolConnectionMode *string `json:"querypoolConnectionMode,omitempty" tf:"querypool_connection_mode,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Required
	Sku *string `json:"sku" tf:"sku,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// ServicesServerSpec defines the desired state of ServicesServer
type ServicesServerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServicesServerParameters `json:"forProvider"`
}

// ServicesServerStatus defines the observed state of ServicesServer.
type ServicesServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServicesServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ServicesServer is the Schema for the ServicesServers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfazure}
type ServicesServer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServicesServerSpec   `json:"spec"`
	Status            ServicesServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServicesServerList contains a list of ServicesServers
type ServicesServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServicesServer `json:"items"`
}

// Repository type metadata.
var (
	ServicesServerKind             = "ServicesServer"
	ServicesServerGroupKind        = schema.GroupKind{Group: Group, Kind: ServicesServerKind}.String()
	ServicesServerKindAPIVersion   = ServicesServerKind + "." + GroupVersion.String()
	ServicesServerGroupVersionKind = GroupVersion.WithKind(ServicesServerKind)
)

func init() {
	SchemeBuilder.Register(&ServicesServer{}, &ServicesServerList{})
}
