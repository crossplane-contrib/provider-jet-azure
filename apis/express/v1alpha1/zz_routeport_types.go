/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IdentityObservation struct {
}

type IdentityParameters struct {

	// +kubebuilder:validation:Optional
	IdentityIds []*string `json:"identityIds,omitempty" tf:"identity_ids,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type Link1Observation struct {
	ConnectorType *string `json:"connectorType,omitempty" tf:"connector_type,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InterfaceName *string `json:"interfaceName,omitempty" tf:"interface_name,omitempty"`

	PatchPanelID *string `json:"patchPanelId,omitempty" tf:"patch_panel_id,omitempty"`

	RackID *string `json:"rackId,omitempty" tf:"rack_id,omitempty"`

	RouterName *string `json:"routerName,omitempty" tf:"router_name,omitempty"`
}

type Link1Parameters struct {

	// +kubebuilder:validation:Optional
	AdminEnabled *bool `json:"adminEnabled,omitempty" tf:"admin_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCakKeyvaultSecretID *string `json:"macsecCakKeyvaultSecretId,omitempty" tf:"macsec_cak_keyvault_secret_id,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCipher *string `json:"macsecCipher,omitempty" tf:"macsec_cipher,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCknKeyvaultSecretID *string `json:"macsecCknKeyvaultSecretId,omitempty" tf:"macsec_ckn_keyvault_secret_id,omitempty"`
}

type Link2Observation struct {
	ConnectorType *string `json:"connectorType,omitempty" tf:"connector_type,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InterfaceName *string `json:"interfaceName,omitempty" tf:"interface_name,omitempty"`

	PatchPanelID *string `json:"patchPanelId,omitempty" tf:"patch_panel_id,omitempty"`

	RackID *string `json:"rackId,omitempty" tf:"rack_id,omitempty"`

	RouterName *string `json:"routerName,omitempty" tf:"router_name,omitempty"`
}

type Link2Parameters struct {

	// +kubebuilder:validation:Optional
	AdminEnabled *bool `json:"adminEnabled,omitempty" tf:"admin_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCakKeyvaultSecretID *string `json:"macsecCakKeyvaultSecretId,omitempty" tf:"macsec_cak_keyvault_secret_id,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCipher *string `json:"macsecCipher,omitempty" tf:"macsec_cipher,omitempty"`

	// +kubebuilder:validation:Optional
	MacsecCknKeyvaultSecretID *string `json:"macsecCknKeyvaultSecretId,omitempty" tf:"macsec_ckn_keyvault_secret_id,omitempty"`
}

type RoutePortObservation struct {
	Ethertype *string `json:"ethertype,omitempty" tf:"ethertype,omitempty"`

	GUID *string `json:"guid,omitempty" tf:"guid,omitempty"`

	Mtu *string `json:"mtu,omitempty" tf:"mtu,omitempty"`
}

type RoutePortParameters struct {

	// +kubebuilder:validation:Required
	BandwidthInGbps *int64 `json:"bandwidthInGbps" tf:"bandwidth_in_gbps,omitempty"`

	// +kubebuilder:validation:Required
	Encapsulation *string `json:"encapsulation" tf:"encapsulation,omitempty"`

	// +kubebuilder:validation:Optional
	Identity []IdentityParameters `json:"identity,omitempty" tf:"identity,omitempty"`

	// +kubebuilder:validation:Optional
	Link1 []Link1Parameters `json:"link1,omitempty" tf:"link1,omitempty"`

	// +kubebuilder:validation:Optional
	Link2 []Link2Parameters `json:"link2,omitempty" tf:"link2,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PeeringLocation *string `json:"peeringLocation" tf:"peering_location,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// RoutePortSpec defines the desired state of RoutePort
type RoutePortSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RoutePortParameters `json:"forProvider"`
}

// RoutePortStatus defines the observed state of RoutePort.
type RoutePortStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RoutePortObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RoutePort is the Schema for the RoutePorts API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfazure}
type RoutePort struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RoutePortSpec   `json:"spec"`
	Status            RoutePortStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RoutePortList contains a list of RoutePorts
type RoutePortList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RoutePort `json:"items"`
}

// Repository type metadata.
var (
	RoutePortKind             = "RoutePort"
	RoutePortGroupKind        = schema.GroupKind{Group: Group, Kind: RoutePortKind}.String()
	RoutePortKindAPIVersion   = RoutePortKind + "." + GroupVersion.String()
	RoutePortGroupVersionKind = GroupVersion.WithKind(RoutePortKind)
)

func init() {
	SchemeBuilder.Register(&RoutePort{}, &RoutePortList{})
}
