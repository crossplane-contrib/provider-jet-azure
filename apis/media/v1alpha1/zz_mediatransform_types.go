/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AudioAnalyzerPresetObservation struct {
}

type AudioAnalyzerPresetParameters struct {

	// +kubebuilder:validation:Optional
	AudioAnalysisMode *string `json:"audioAnalysisMode,omitempty" tf:"audio_analysis_mode,omitempty"`

	// +kubebuilder:validation:Optional
	AudioLanguage *string `json:"audioLanguage,omitempty" tf:"audio_language,omitempty"`
}

type BuiltinPresetObservation struct {
}

type BuiltinPresetParameters struct {

	// +kubebuilder:validation:Optional
	PresetName *string `json:"presetName,omitempty" tf:"preset_name,omitempty"`
}

type FaceDetectorPresetObservation struct {
}

type FaceDetectorPresetParameters struct {

	// +kubebuilder:validation:Optional
	AnalysisResolution *string `json:"analysisResolution,omitempty" tf:"analysis_resolution,omitempty"`
}

type MediaTransformObservation struct {
}

type MediaTransformParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	MediaServicesAccountName *string `json:"mediaServicesAccountName" tf:"media_services_account_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Output []OutputParameters `json:"output,omitempty" tf:"output,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`
}

type OutputObservation struct {
}

type OutputParameters struct {

	// +kubebuilder:validation:Optional
	AudioAnalyzerPreset []AudioAnalyzerPresetParameters `json:"audioAnalyzerPreset,omitempty" tf:"audio_analyzer_preset,omitempty"`

	// +kubebuilder:validation:Optional
	BuiltinPreset []BuiltinPresetParameters `json:"builtinPreset,omitempty" tf:"builtin_preset,omitempty"`

	// +kubebuilder:validation:Optional
	FaceDetectorPreset []FaceDetectorPresetParameters `json:"faceDetectorPreset,omitempty" tf:"face_detector_preset,omitempty"`

	// +kubebuilder:validation:Optional
	OnErrorAction *string `json:"onErrorAction,omitempty" tf:"on_error_action,omitempty"`

	// +kubebuilder:validation:Optional
	RelativePriority *string `json:"relativePriority,omitempty" tf:"relative_priority,omitempty"`

	// +kubebuilder:validation:Optional
	VideoAnalyzerPreset []VideoAnalyzerPresetParameters `json:"videoAnalyzerPreset,omitempty" tf:"video_analyzer_preset,omitempty"`
}

type VideoAnalyzerPresetObservation struct {
}

type VideoAnalyzerPresetParameters struct {

	// +kubebuilder:validation:Optional
	AudioAnalysisMode *string `json:"audioAnalysisMode,omitempty" tf:"audio_analysis_mode,omitempty"`

	// +kubebuilder:validation:Optional
	AudioLanguage *string `json:"audioLanguage,omitempty" tf:"audio_language,omitempty"`

	// +kubebuilder:validation:Optional
	InsightsType *string `json:"insightsType,omitempty" tf:"insights_type,omitempty"`
}

// MediaTransformSpec defines the desired state of MediaTransform
type MediaTransformSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MediaTransformParameters `json:"forProvider"`
}

// MediaTransformStatus defines the observed state of MediaTransform.
type MediaTransformStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MediaTransformObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MediaTransform is the Schema for the MediaTransforms API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type MediaTransform struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MediaTransformSpec   `json:"spec"`
	Status            MediaTransformStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MediaTransformList contains a list of MediaTransforms
type MediaTransformList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MediaTransform `json:"items"`
}

// Repository type metadata.
var (
	MediaTransformKind             = "MediaTransform"
	MediaTransformGroupKind        = schema.GroupKind{Group: Group, Kind: MediaTransformKind}.String()
	MediaTransformKindAPIVersion   = MediaTransformKind + "." + GroupVersion.String()
	MediaTransformGroupVersionKind = GroupVersion.WithKind(MediaTransformKind)
)

func init() {
	SchemeBuilder.Register(&MediaTransform{}, &MediaTransformList{})
}
