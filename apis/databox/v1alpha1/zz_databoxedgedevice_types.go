/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type DataboxEdgeDeviceObservation struct {
	DeviceProperties []DevicePropertiesObservation `json:"deviceProperties" tf:"device_properties"`
}

type DataboxEdgeDeviceParameters struct {
	Location string `json:"location" tf:"location"`

	Name string `json:"name" tf:"name"`

	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	SkuName string `json:"skuName" tf:"sku_name"`

	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

type DevicePropertiesObservation struct {
	Capacity int64 `json:"capacity" tf:"capacity"`

	ConfiguredRoleTypes []string `json:"configuredRoleTypes" tf:"configured_role_types"`

	Culture string `json:"culture" tf:"culture"`

	HcsVersion string `json:"hcsVersion" tf:"hcs_version"`

	Model string `json:"model" tf:"model"`

	NodeCount int64 `json:"nodeCount" tf:"node_count"`

	SerialNumber string `json:"serialNumber" tf:"serial_number"`

	SoftwareVersion string `json:"softwareVersion" tf:"software_version"`

	Status string `json:"status" tf:"status"`

	TimeZone string `json:"timeZone" tf:"time_zone"`

	Type string `json:"type" tf:"type"`
}

type DevicePropertiesParameters struct {
}

// DataboxEdgeDeviceSpec defines the desired state of DataboxEdgeDevice
type DataboxEdgeDeviceSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       DataboxEdgeDeviceParameters `json:"forProvider"`
}

// DataboxEdgeDeviceStatus defines the observed state of DataboxEdgeDevice.
type DataboxEdgeDeviceStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          DataboxEdgeDeviceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DataboxEdgeDevice is the Schema for the DataboxEdgeDevices API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type DataboxEdgeDevice struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DataboxEdgeDeviceSpec   `json:"spec"`
	Status            DataboxEdgeDeviceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DataboxEdgeDeviceList contains a list of DataboxEdgeDevices
type DataboxEdgeDeviceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataboxEdgeDevice `json:"items"`
}

// Repository type metadata.
var (
	DataboxEdgeDeviceKind             = "DataboxEdgeDevice"
	DataboxEdgeDeviceGroupKind        = schema.GroupKind{Group: Group, Kind: DataboxEdgeDeviceKind}.String()
	DataboxEdgeDeviceKindAPIVersion   = DataboxEdgeDeviceKind + "." + GroupVersion.String()
	DataboxEdgeDeviceGroupVersionKind = GroupVersion.WithKind(DataboxEdgeDeviceKind)
)

func init() {
	SchemeBuilder.Register(&DataboxEdgeDevice{}, &DataboxEdgeDeviceList{})
}
