/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendObservation struct {
}

type BackendParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	HTTPPort *int64 `json:"httpPort" tf:"http_port,omitempty"`

	// +kubebuilder:validation:Required
	HTTPSPort *int64 `json:"httpsPort" tf:"https_port,omitempty"`

	// +kubebuilder:validation:Required
	HostHeader *string `json:"hostHeader" tf:"host_header,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	Weight *int64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type BackendPoolHealthProbeObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendPoolHealthProbeParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalInSeconds *int64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	ProbeMethod *string `json:"probeMethod,omitempty" tf:"probe_method,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type BackendPoolLoadBalancingObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendPoolLoadBalancingParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalLatencyMilliseconds *int64 `json:"additionalLatencyMilliseconds,omitempty" tf:"additional_latency_milliseconds,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SampleSize *int64 `json:"sampleSize,omitempty" tf:"sample_size,omitempty"`

	// +kubebuilder:validation:Optional
	SuccessfulSamplesRequired *int64 `json:"successfulSamplesRequired,omitempty" tf:"successful_samples_required,omitempty"`
}

type BackendPoolObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendPoolParameters struct {

	// +kubebuilder:validation:Required
	Backend []BackendParameters `json:"backend" tf:"backend,omitempty"`

	// +kubebuilder:validation:Required
	HealthProbeName *string `json:"healthProbeName" tf:"health_probe_name,omitempty"`

	// +kubebuilder:validation:Required
	LoadBalancingName *string `json:"loadBalancingName" tf:"load_balancing_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type ExplicitResourceOrderObservation struct {
	BackendPoolHealthProbeIds []*string `json:"backendPoolHealthProbeIds,omitempty" tf:"backend_pool_health_probe_ids,omitempty"`

	BackendPoolIds []*string `json:"backendPoolIds,omitempty" tf:"backend_pool_ids,omitempty"`

	BackendPoolLoadBalancingIds []*string `json:"backendPoolLoadBalancingIds,omitempty" tf:"backend_pool_load_balancing_ids,omitempty"`

	FrontendEndpointIds []*string `json:"frontendEndpointIds,omitempty" tf:"frontend_endpoint_ids,omitempty"`

	RoutingRuleIds []*string `json:"routingRuleIds,omitempty" tf:"routing_rule_ids,omitempty"`
}

type ExplicitResourceOrderParameters struct {
}

type ForwardingConfigurationObservation struct {
}

type ForwardingConfigurationParameters struct {

	// +kubebuilder:validation:Required
	BackendPoolName *string `json:"backendPoolName" tf:"backend_pool_name,omitempty"`

	// +kubebuilder:validation:Optional
	CacheDuration *string `json:"cacheDuration,omitempty" tf:"cache_duration,omitempty"`

	// +kubebuilder:validation:Optional
	CacheEnabled *bool `json:"cacheEnabled,omitempty" tf:"cache_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	CacheQueryParameterStripDirective *string `json:"cacheQueryParameterStripDirective,omitempty" tf:"cache_query_parameter_strip_directive,omitempty"`

	// +kubebuilder:validation:Optional
	CacheQueryParameters []*string `json:"cacheQueryParameters,omitempty" tf:"cache_query_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	CacheUseDynamicCompression *bool `json:"cacheUseDynamicCompression,omitempty" tf:"cache_use_dynamic_compression,omitempty"`

	// +kubebuilder:validation:Optional
	CustomForwardingPath *string `json:"customForwardingPath,omitempty" tf:"custom_forwarding_path,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardingProtocol *string `json:"forwardingProtocol,omitempty" tf:"forwarding_protocol,omitempty"`
}

type FrontdoorObservation struct {
	BackendPoolHealthProbes map[string]*string `json:"backendPoolHealthProbes,omitempty" tf:"backend_pool_health_probes,omitempty"`

	BackendPoolLoadBalancingSettings map[string]*string `json:"backendPoolLoadBalancingSettings,omitempty" tf:"backend_pool_load_balancing_settings,omitempty"`

	BackendPools map[string]*string `json:"backendPools,omitempty" tf:"backend_pools,omitempty"`

	Cname *string `json:"cname,omitempty" tf:"cname,omitempty"`

	ExplicitResourceOrder []ExplicitResourceOrderObservation `json:"explicitResourceOrder,omitempty" tf:"explicit_resource_order,omitempty"`

	FrontendEndpoints map[string]*string `json:"frontendEndpoints,omitempty" tf:"frontend_endpoints,omitempty"`

	HeaderFrontdoorID *string `json:"headerFrontdoorId,omitempty" tf:"header_frontdoor_id,omitempty"`

	RoutingRules map[string]*string `json:"routingRules,omitempty" tf:"routing_rules,omitempty"`
}

type FrontdoorParameters struct {

	// +kubebuilder:validation:Required
	BackendPool []BackendPoolParameters `json:"backendPool" tf:"backend_pool,omitempty"`

	// +kubebuilder:validation:Required
	BackendPoolHealthProbe []BackendPoolHealthProbeParameters `json:"backendPoolHealthProbe" tf:"backend_pool_health_probe,omitempty"`

	// +kubebuilder:validation:Required
	BackendPoolLoadBalancing []BackendPoolLoadBalancingParameters `json:"backendPoolLoadBalancing" tf:"backend_pool_load_balancing,omitempty"`

	// +kubebuilder:validation:Optional
	BackendPoolsSendReceiveTimeoutSeconds *int64 `json:"backendPoolsSendReceiveTimeoutSeconds,omitempty" tf:"backend_pools_send_receive_timeout_seconds,omitempty"`

	// +kubebuilder:validation:Required
	EnforceBackendPoolsCertificateNameCheck *bool `json:"enforceBackendPoolsCertificateNameCheck" tf:"enforce_backend_pools_certificate_name_check,omitempty"`

	// +kubebuilder:validation:Optional
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name,omitempty"`

	// +kubebuilder:validation:Required
	FrontendEndpoint []FrontendEndpointParameters `json:"frontendEndpoint" tf:"frontend_endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerEnabled *bool `json:"loadBalancerEnabled,omitempty" tf:"load_balancer_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Required
	RoutingRule []RoutingRuleParameters `json:"routingRule" tf:"routing_rule,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type FrontendEndpointObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type FrontendEndpointParameters struct {

	// +kubebuilder:validation:Required
	HostName *string `json:"hostName" tf:"host_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SessionAffinityEnabled *bool `json:"sessionAffinityEnabled,omitempty" tf:"session_affinity_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	SessionAffinityTTLSeconds *int64 `json:"sessionAffinityTtlSeconds,omitempty" tf:"session_affinity_ttl_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	WebApplicationFirewallPolicyLinkID *string `json:"webApplicationFirewallPolicyLinkId,omitempty" tf:"web_application_firewall_policy_link_id,omitempty"`
}

type RedirectConfigurationObservation struct {
}

type RedirectConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CustomFragment *string `json:"customFragment,omitempty" tf:"custom_fragment,omitempty"`

	// +kubebuilder:validation:Optional
	CustomHost *string `json:"customHost,omitempty" tf:"custom_host,omitempty"`

	// +kubebuilder:validation:Optional
	CustomPath *string `json:"customPath,omitempty" tf:"custom_path,omitempty"`

	// +kubebuilder:validation:Optional
	CustomQueryString *string `json:"customQueryString,omitempty" tf:"custom_query_string,omitempty"`

	// +kubebuilder:validation:Required
	RedirectProtocol *string `json:"redirectProtocol" tf:"redirect_protocol,omitempty"`

	// +kubebuilder:validation:Required
	RedirectType *string `json:"redirectType" tf:"redirect_type,omitempty"`
}

type RoutingRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RoutingRuleParameters struct {

	// +kubebuilder:validation:Required
	AcceptedProtocols []*string `json:"acceptedProtocols" tf:"accepted_protocols,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardingConfiguration []ForwardingConfigurationParameters `json:"forwardingConfiguration,omitempty" tf:"forwarding_configuration,omitempty"`

	// +kubebuilder:validation:Required
	FrontendEndpoints []*string `json:"frontendEndpoints" tf:"frontend_endpoints,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PatternsToMatch []*string `json:"patternsToMatch" tf:"patterns_to_match,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectConfiguration []RedirectConfigurationParameters `json:"redirectConfiguration,omitempty" tf:"redirect_configuration,omitempty"`
}

// FrontdoorSpec defines the desired state of Frontdoor
type FrontdoorSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FrontdoorParameters `json:"forProvider"`
}

// FrontdoorStatus defines the observed state of Frontdoor.
type FrontdoorStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FrontdoorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Frontdoor is the Schema for the Frontdoors API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type Frontdoor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FrontdoorSpec   `json:"spec"`
	Status            FrontdoorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FrontdoorList contains a list of Frontdoors
type FrontdoorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Frontdoor `json:"items"`
}

// Repository type metadata.
var (
	FrontdoorKind             = "Frontdoor"
	FrontdoorGroupKind        = schema.GroupKind{Group: Group, Kind: FrontdoorKind}.String()
	FrontdoorKindAPIVersion   = FrontdoorKind + "." + GroupVersion.String()
	FrontdoorGroupVersionKind = GroupVersion.WithKind(FrontdoorKind)
)

func init() {
	SchemeBuilder.Register(&Frontdoor{}, &FrontdoorList{})
}
