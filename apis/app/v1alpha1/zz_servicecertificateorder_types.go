/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CertificatesObservation struct {
	CertificateName *string `json:"certificateName,omitempty" tf:"certificate_name,omitempty"`

	KeyVaultID *string `json:"keyVaultId,omitempty" tf:"key_vault_id,omitempty"`

	KeyVaultSecretName *string `json:"keyVaultSecretName,omitempty" tf:"key_vault_secret_name,omitempty"`

	ProvisioningState *string `json:"provisioningState,omitempty" tf:"provisioning_state,omitempty"`
}

type CertificatesParameters struct {
}

type ServiceCertificateOrderObservation struct {
	AppServiceCertificateNotRenewableReasons []*string `json:"appServiceCertificateNotRenewableReasons,omitempty" tf:"app_service_certificate_not_renewable_reasons,omitempty"`

	Certificates []CertificatesObservation `json:"certificates,omitempty" tf:"certificates,omitempty"`

	DomainVerificationToken *string `json:"domainVerificationToken,omitempty" tf:"domain_verification_token,omitempty"`

	ExpirationTime *string `json:"expirationTime,omitempty" tf:"expiration_time,omitempty"`

	IntermediateThumbprint *string `json:"intermediateThumbprint,omitempty" tf:"intermediate_thumbprint,omitempty"`

	IsPrivateKeyExternal *bool `json:"isPrivateKeyExternal,omitempty" tf:"is_private_key_external,omitempty"`

	RootThumbprint *string `json:"rootThumbprint,omitempty" tf:"root_thumbprint,omitempty"`

	SignedCertificateThumbprint *string `json:"signedCertificateThumbprint,omitempty" tf:"signed_certificate_thumbprint,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ServiceCertificateOrderParameters struct {

	// +kubebuilder:validation:Optional
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// +kubebuilder:validation:Optional
	Csr *string `json:"csr,omitempty" tf:"csr,omitempty"`

	// +kubebuilder:validation:Optional
	DistinguishedName *string `json:"distinguishedName,omitempty" tf:"distinguished_name,omitempty"`

	// +kubebuilder:validation:Optional
	KeySize *int64 `json:"keySize,omitempty" tf:"key_size,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ProductType *string `json:"productType,omitempty" tf:"product_type,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	ValidityInYears *int64 `json:"validityInYears,omitempty" tf:"validity_in_years,omitempty"`
}

// ServiceCertificateOrderSpec defines the desired state of ServiceCertificateOrder
type ServiceCertificateOrderSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceCertificateOrderParameters `json:"forProvider"`
}

// ServiceCertificateOrderStatus defines the observed state of ServiceCertificateOrder.
type ServiceCertificateOrderStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceCertificateOrderObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceCertificateOrder is the Schema for the ServiceCertificateOrders API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfazure}
type ServiceCertificateOrder struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServiceCertificateOrderSpec   `json:"spec"`
	Status            ServiceCertificateOrderStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceCertificateOrderList contains a list of ServiceCertificateOrders
type ServiceCertificateOrderList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceCertificateOrder `json:"items"`
}

// Repository type metadata.
var (
	ServiceCertificateOrderKind             = "ServiceCertificateOrder"
	ServiceCertificateOrderGroupKind        = schema.GroupKind{Group: Group, Kind: ServiceCertificateOrderKind}.String()
	ServiceCertificateOrderKindAPIVersion   = ServiceCertificateOrderKind + "." + GroupVersion.String()
	ServiceCertificateOrderGroupVersionKind = GroupVersion.WithKind(ServiceCertificateOrderKind)
)

func init() {
	SchemeBuilder.Register(&ServiceCertificateOrder{}, &ServiceCertificateOrderList{})
}
